#!/usr/bin/env python3
"""
Script to generate secure values for environment variables.
This script reads the .env.example file and generates secure random values
for each environment variable, creating a new .env file.
"""

import os
import re
import secrets
import string
import argparse
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(f"env_generation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
    ]
)

logger = logging.getLogger("env_generator")

def generate_secure_value(var_name):
    """
    Generate a secure random value based on the variable name.
    
    Args:
        var_name: The name of the environment variable
        
    Returns:
        A secure random string appropriate for the variable type
    """
    # Define character sets for different types of secrets
    letters = string.ascii_letters
    digits = string.digits
    special_chars = string.punctuation
    
    # Default length and character set
    length = 32
    chars = letters + digits
    
    # Adjust based on variable name patterns
    if "API_KEY" in var_name or "APIKEY" in var_name:
        # API keys are typically alphanumeric
        length = 40
        chars = letters + digits
    elif "SECRET_KEY" in var_name or "SECRET" in var_name:
        # Secret keys should be more complex
        length = 48
        chars = letters + digits + special_chars
    elif "PASSWORD" in var_name or "PWD" in var_name:
        # Passwords should include special characters
        length = 24
        chars = letters + digits + special_chars
    elif "TOKEN" in var_name:
        # Tokens are often longer
        length = 64
        chars = letters + digits
    elif "PRIVATE_KEY" in var_name:
        # For demonstration - in reality, private keys would have specific formats
        length = 64
        chars = letters + digits + special_chars
    
    # Generate the random value
    return ''.join(secrets.choice(chars) for _ in range(length))

def read_env_example(file_path):
    """
    Read the .env.example file and extract variable names.
    
    Args:
        file_path: Path to the .env.example file
        
    Returns:
        A list of environment variable names
    """
    var_names = []
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                # Skip comments and empty lines
                if line.strip() and not line.strip().startswith('#'):
                    # Extract variable name (everything before =)
                    match = re.match(r'^([A-Za-z0-9_]+)=', line.strip())
                    if match:
                        var_names.append(match.group(1))
    except Exception as e:
        logger.error(f"Error reading {file_path}: {str(e)}")
        raise
    
    return var_names

def generate_env_file(example_path, output_path, overwrite=False):
    """
    Generate a .env file with secure random values.
    
    Args:
        example_path: Path to the .env.example file
        output_path: Path to the output .env file
        overwrite: Whether to overwrite an existing .env file
    """
    if os.path.exists(output_path) and not overwrite:
        logger.error(f"{output_path} already exists. Use --overwrite to replace it.")
        return False
    
    try:
        # Read variable names from .env.example
        var_names = read_env_example(example_path)
        logger.info(f"Found {len(var_names)} environment variables in {example_path}")
        
        # Generate secure values for each variable
        env_vars = {}
        for var_name in var_names:
            env_vars[var_name] = generate_secure_value(var_name)
        
        # Write to .env file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("# Environment variables for the EyewearML application\n")
            f.write(f"# Generated by {os.path.basename(__file__)} on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            for var_name, value in env_vars.items():
                f.write(f"{var_name}={value}\n")
        
        logger.info(f"Successfully generated {output_path} with {len(env_vars)} environment variables")
        return True
    
    except Exception as e:
        logger.error(f"Error generating {output_path}: {str(e)}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Generate secure environment variables')
    parser.add_argument('--example', default='.env.example', help='Path to the .env.example file')
    parser.add_argument('--output', default='.env', help='Path to the output .env file')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing .env file')
    
    args = parser.parse_args()
    
    if generate_env_file(args.example, args.output, args.overwrite):
        logger.info("Environment file generation completed successfully")
    else:
        logger.error("Environment file generation failed")
        exit(1)

if __name__ == "__main__":
    main()